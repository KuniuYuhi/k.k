#include "stdafx.h"
#include "Brave.h"
#include "BraveStateIdle.h"
#include "BraveStateSprint.h"
#include "BraveStateAttack_1.h"
#include "BraveStateAttack_2.h"
#include "BraveStateAttack_3.h"
#include "BraveStateSkill_Start.h"
#include "BraveStateSkill_Main.h"
#include "BraveStateDefend.h"
#include "BraveStateDefendHit.h"
#include "BraveStateHit.h"
#include "BraveStateDie.h"
#include "BraveStateChangeSwordShield.h"
#include "BraveStateWin_Start.h"
#include "BraveStateWin_Main.h"

#include "Player.h"

#include "SwordShield.h"
#include "BigSword.h"


//todo たまにダークボールの当たった時の爆発がない
//todo スキル使用時fpsが低いと地面との判定を取ってくれない

//todo ジャストガードでカウンター(パリィ)
//もしくはガード中に敵の攻撃に合わせてボタンを押して反撃。敵は怯む

namespace {
	const float ADD_SCALE = 1.2f;

	const float ROT_SPEED = 20.0f;
	const float ROT_ONLY_SPEED = 20.0f;

	const float SWORD_EFFECT_SIZE = 10.0f;
	const Vector3 DASH_EFFECT_SIZE = { 10.0f,20.0f,8.0f };

	int MAXHP = 200;
	int MAXMP = 100;
	int ATK = 40;
	float SPEED = 200.0f;
	const char* NAME = "Brave";

	const int SKILL_ATTACK_POWER = 30;
}

Brave::Brave()
{
}

Brave::~Brave()
{
	DeleteGO(m_subWeapon);
	DeleteGO(m_mainWeapon);
}

bool Brave::Start()
{
	m_player = FindGO<Player>("player");

	//ステータスの初期化
	m_status.InitStatus(
		MAXHP,
		MAXMP,
		ATK,
		SPEED,
		NAME
	);

	InitModel();

	//キャラコンの設定
	m_charaCon.Init(12.0f, 33.0f, m_position);

	//武器の生成
	m_subWeapon = NewGO<BigSword>(0, "bigsword");
	m_mainWeapon = NewGO<SwordShield>(0,"swordshield");

	m_useWeapon[enWeapon_Main].weapon = m_mainWeapon;
	m_useWeapon[enWeapon_Main].weaponAnimationStartIndexNo
		= OneHandSwordAnimationStartIndexNo;

	m_useWeapon[enWeapon_Sub].weapon = m_subWeapon;
	m_useWeapon[enWeapon_Sub].weaponAnimationStartIndexNo
		= TwoHandSwordAnimationStartIndexNo;

	//現在の武器のアニメーションクリップの最初の番号
	m_currentAnimationStartIndexNo 
		= m_useWeapon[enWeapon_Main].weaponAnimationStartIndexNo;

	SetNextAnimationState(enAninationState_Idle);

	return true;
}

void Brave::Update()
{
	//行動不可能な状態でないなら
	if (IsInaction() != true)
	{
		//MPの回復
		RecoveryMP();
		//武器の切り替え処理
		ChangeWeapon();
		//移動処理
		Move();
		//回転処理
		ProcessRotation();
		//攻撃処理
		ProcessAttack();
		//防御処理
		ProcessDefend();
		//無敵時間の計算
		CalcInvincibleTime();
		//当たり判定
		DamageCollision(m_charaCon);
	}
	

	ManageState();
	PlayAnimation();
	
	SetTransFormModel(m_modelRender);

	m_modelRender.Update();
	
}

void Brave::Move()
{
	m_moveSpeed = calcVelocity(GetStatus());
	m_moveSpeed.y = 0.0f;

	m_position = m_charaCon.Execute(m_moveSpeed, 1.0f / 60.0f);
}

void Brave::ProcessRotation()
{
	Rotation(ROT_SPEED, ROT_ONLY_SPEED);
}

void Brave::ProcessAttack()
{
	//アクションフラグがtrueなら攻撃処理をしない
	if (GetIsActionFlag() == true)
	{
		return;
	}
	//通常攻撃
	if (g_pad[0]->IsTrigger(enButtonA))
	{
		ProcessComboAttack();
		return;
	}
	//スキル
	if (g_pad[0]->IsTrigger(enButtonB))
	{
		//アクションフラグをセット
		SetIsActionFlag(true);
		SetNextAnimationState(enAnimationState_Skill_start);
	}

}

void Brave::ProcessDefend()
{
	//アクションフラグがtrueなら攻撃処理をしない
	if (GetIsActionFlag() == true)
	{
		return;
	}
	//防御

	if (g_pad[0]->IsTrigger(enButtonY) == true)
	{
		//アクションフラグをセット
		SetIsActionFlag(true);
		SetNextAnimationState(enAnimationState_Defend);
	}
}

void Brave::Damage(int damage)
{
	//HPが0より大きいなら被ダメージ処理
	if (GetStatus().hp > 0)
	{
		//コンボが繋がっている時にダメージを受けたかもしれないのでリセット
		m_attackPatternState = enAttackPattern_None;

		//武器切り替え中にダメージを受けたら
		if (m_enAnimationState == enAnimationState_ChangeSwordShield)
		{
			//武器切り替え前の武器のアニメーションが再生されるようにする
			m_currentAnimationStartIndexNo
				= m_useWeapon[enWeapon_Main].weaponAnimationStartIndexNo;
		}

		if (IsDefendHit() == true)
		{
			//ダメージを1/3に減らす
			damage /= 3;
			//どれだけダメージを減らしても１以下にはならない
			if (damage < 1) { damage = 1; }
			//盾ヒットステートに遷移
			SetNextAnimationState(enAnimationState_DefendHit);
		}
		else
		{
			//普通にダメージを受ける
			//ヒットステートに遷移
			SetNextAnimationState(enAnimationState_Hit);
		}

		//受けるダメージを決定
		m_hitDamage = damage;
		m_status.CalcHp(m_hitDamage, false);
		//ダメージを受けたので無敵時間に入る
		SetInvicibleTimeFlag(true);
	}
	//HPが0以下なら
	if (GetStatus().hp <= 0)
	{
		//やられたのでdieFlagをtrueにする
		SetDieFlag(true);
		//点滅しないようにする
		SetInvicibleTimeFlag(false);
		//HPを0に固定する
		m_status.SetHp(0);
		//死亡ステートに遷移
		SetNextAnimationState(enAnimationState_Die);
	}
}

const bool& Brave::IsInaction() const
{
	//行動出来なくなる条件
	//プレイヤークラスの関数の動けない条件がtrueなら
	if (m_player->IsInaction() == true)
	{
		return true;
	}
	//やられたなら
	if (GetDieFlag() == true)
	{
		return true;
	}
	//ここまできたら行動可能
	return false;
}

void Brave::MoveForward(float Speed)
{
	//攻撃する方向
	Vector3 attackDirection = m_forward;
	//移動する速度
	Vector3 MoveSpeed = attackDirection * Speed;
	MoveSpeed.y = 0.0f;
	m_position = m_charaCon.Execute(MoveSpeed, 1.0f / 60.0f);
	m_modelRender.SetPosition(m_position);
}

void Brave::ChangeWeapon()
{
	//アクションフラグがtrueなら攻撃処理をしない
	if (GetIsActionFlag() == true)
	{
		return;
	}
	//武器の切り替え
	if (g_pad[0]->IsTrigger(enButtonRB1) == true)
	{
		//武器のサブとメインの中身を入れ替える
		//現在の武器のアニメーションクリップの最初の番号をサブに変更
		m_currentAnimationStartIndexNo
			= m_useWeapon[enWeapon_Sub].weaponAnimationStartIndexNo;

		SetNextAnimationState(enAnimationState_ChangeSwordShield);
		SetIsActionFlag(true);
	}
}

void Brave::ProcessWin()
{
	//点滅しないようにする
	SetInvicibleTimeFlag(false);
	//勝利スタートのステート
	SetNextAnimationState(enAnimationState_Win_Start);
}

void Brave::ProcessSwordShieldSkill(bool UpOrDownFlag)
{
	Vector3 Y = g_vec3AxisY;
	float mulYPos = 0.0f;
	if (UpOrDownFlag == true)
	{
		//Up処理
		mulYPos += 
			g_gameTime->GetFrameDeltaTime() * m_useWeapon[enWeapon_Main].weapon->GetJampSpeed();
		Y.y += mulYPos;
	}
	else
	{
		//Down処理
		mulYPos += 
			g_gameTime->GetFrameDeltaTime() * m_useWeapon[enWeapon_Main].weapon->GetJampSpeed() * 1.5f;
		Y.y -= mulYPos;
	}
	
	m_position = m_charaCon.Execute(Y, 1.0f / 30.0f);
	//地面についているなら
	if (m_charaCon.IsOnGround() == true|| m_position.y < 0.0f)
	{
		m_position.y = 0.0f;
	}

	m_modelRender.SetPosition(m_position);
}

void Brave::SetNextAnimationState(int nextState)
{
	if (m_BraveState != nullptr) {
		// 古いステートを削除する。
		delete m_BraveState;
		m_BraveState = nullptr;
	}
	
	//アニメーションステートを次のステートに変える
	m_enAnimationState = (EnAnimationState)nextState;

	switch (m_enAnimationState)
	{
	case Brave::enAninationState_Idle:
		m_BraveState = new BraveStateIdle(this);
		break;
	case Brave::enAninationState_Sprint:
		m_BraveState = new BraveStateSprint(this);
		break;
	case Brave::enAninationState_DashForward:
		break;
	case Brave::enAnimationState_KnockBack:
		break;
	case Brave::enAnimationState_Hit:
		m_BraveState = new BraveStateHit(this);
		break;
	case Brave::enAnimationState_Defend:
		m_BraveState = new BraveStateDefend(this);
		break;
	case Brave::enAnimationState_DefendHit:
		m_BraveState = new BraveStateDefendHit(this);
		break;
	case Brave::enAnimationState_Die:
		m_BraveState = new BraveStateDie(this);
		break;
	case Brave::enAnimationState_ChangeSwordShield:
		m_BraveState = new BraveStateChangeSwordShield(this);
		break;
	case Brave::enAnimationState_Win_Start:
		m_BraveState = new BraveStateWin_Start(this);
		break;
	case Brave::enAnimationState_Win_Main:
		m_BraveState = new BraveStateWin_Main(this);
		break;
	case Brave::enAnimationState_Attack_1:
		m_BraveState = new BraveStateAttack_1(this);
		break;
	case Brave::enAnimationState_Attack_2:
		m_BraveState = new BraveStateAttack_2(this);
		break;
	case Brave::enAnimationState_Attack_3:
		m_BraveState = new BraveStateAttack_3(this);
		break;
	case Brave::enAnimationState_Skill_start:
		m_BraveState = new BraveStateSkill_Start(this);
		break;
	case Brave::enAnimationState_Skill_Main:
		m_BraveState = new BraveStateSkill_Main(this);
		break;
	default:
		break;
	}
}

void Brave::PlayAnimation()
{
	//派生クラスのPlayAnimation関数を実行
	m_BraveState->PlayAnimation();
}

void Brave::ManageState()
{
	//派生クラスのManageState関数を実行
	m_BraveState->ManageState();
}

void Brave::ProcessComboAttack()
{
	//パターンステートを一つ進める
	m_attackPatternState =
		static_cast<EnAttackPattern>(m_attackPatternState + 1);

	//通常攻撃ステート設定
	SetNextAnimationState(m_attackPatternState);
	//敵のためのコンボステートを設定
	switch (m_attackPatternState)
	{
	case Brave::enAttackPattern_None:
		SetNowComboState(enNowCombo_None);
		break;
	case Brave::enAttackPattern_1:
		SetNowComboState(enNowCombo_1);
		break;
	case Brave::enAttackPattern_2:
		SetNowComboState(enNowCombo_2);
		break;
	case Brave::enAttackPattern_3:
		SetNowComboState(enNowCombo_3);
		break;
	case Brave::enAttackPattern_End:
		break;
	default:
		break;
	}
	//3コンボ以上ならパターンステートリセット
	if (m_attackPatternState >= enAttackPattern_3)
	{
		m_attackPatternState = enAttackPattern_None;
	}

	//アクションフラグをセット
	SetIsActionFlag(true);
}

void Brave::ProcessCommonStateTransition()
{
	if (fabsf(GetMoveSpeed().x) >= 0.001f ||
		fabsf(GetMoveSpeed().z) >= 0.001f
		)
	{
		//走る
		SetNextAnimationState(enAninationState_Sprint);
	}
	else
	{
		//歩く
		SetNextAnimationState(enAninationState_Idle);
	}
}

void Brave::ProcessCommonWeaponChangeStateTransition()
{
	//アニメーションの再生が終わったら
	if (m_modelRender.IsPlayingAnimation() == false)
	{
		//todo 無敵状態フラグのリセット
		SetInvicibleFlag(false);
		//現在の武器のアニメーションクリップの最初の番号を変更
		m_currentAnimationStartIndexNo
			= m_useWeapon[enWeapon_Main].weaponAnimationStartIndexNo;
		//切り替えアニメーションが終わったのでアクションフラグをfalseにする
		SetIsActionFlag(false);
		//ステート共通の状態遷移処理に遷移
		ProcessCommonStateTransition();
	}
}

void Brave::ProcessNormalAttackStateTransition()
{
	//アニメーションの再生が終わったら
	if (m_modelRender.IsPlayingAnimation() == false)
	{
		//次のコンボに繋げない、または3コンボ目ならリセット
		if (GetNextComboFlagFlag() == false ||
			m_attackPatternState == enAttackPattern_None)
		{
			m_position.y = 0.0f;
			m_attackPatternState = enAttackPattern_None;
			//攻撃アニメーションが終わったのでアクションフラグをfalseにする
			SetIsActionFlag(false);
			//コンボ状態をリセット
			SetComboStateNone();
			//ステート共通の状態遷移処理に遷移
			ProcessCommonStateTransition();
		}
		//次のコンボの攻撃ステート設定
		else
		{
			//次のコンボに移る前に回転する
			if (fabsf(m_SaveMoveSpeed.x) >= 0.001f || fabsf(m_SaveMoveSpeed.z) >= 0.001f)
			{
				m_rotation.SetRotationYFromDirectionXZ(m_SaveMoveSpeed);
			}
			//次のコンボの処理
			ProcessComboAttack();
		}
		//必ずリセット
		{
			//コンボ受付フラグをリセット
			SetIsComboReceptionFlagFlag(false);
			//次のコンボフラグをリセット
			SetNextComboFlagFlag(false);
		}
	}
	//コンボ受付フラグがtrueかつAボタンを押したら
	else if (GetIsComboReceptionFlagFlag() == true &&
		g_pad[0]->IsTrigger(enButtonA))
	{
		//次のコンボに進むフラグセット
		SetNextComboFlagFlag(true);
	}
}

void Brave::ProcessSkillStartStateTransition()
{
	if (m_modelRender.IsPlayingAnimation() == false)
	{
		//メインステートに遷移
		SetNextAnimationState(enAnimationState_Skill_Main);
	}
}

void Brave::ProcessSkillMainStateTransition()
{
	if (m_modelRender.IsPlayingAnimation() == false)
	{
		//todo 無敵状態フラグのリセット
		SetInvicibleFlag(false);
		//攻撃アニメーションが終わったので攻撃可能
		SetIsActionFlag(false);
		//ステート共通の状態遷移処理に遷移
		ProcessCommonStateTransition();
	}
}

void Brave::ProcessHitStateTransition()
{
	if (m_modelRender.IsPlayingAnimation() == false)
	{
		//アクション中にダメージ受けたかもしれないので
		// アクションフラグ関係を全てfalseにする
		SetAllInfoAboutActionFlag(false);
		//コンボ状態をリセット
		SetComboStateNone();
		//ステート共通の状態遷移処理に遷移
		ProcessCommonStateTransition();
	}
}

void Brave::ProcessDieStateTransition()
{
	if (m_modelRender.IsPlayingAnimation() == false)
	{
		//やられたのでdieFlagをtrueにする
		SetDieFlag(true);
	}
}

void Brave::ProcessDefendStateTransition()
{
	if (m_modelRender.IsPlayingAnimation() == false)
	{
		//アクション中にダメージ受けたかもしれないので
		// アクションフラグ関係を全てfalseにする
		SetAllInfoAboutActionFlag(false);
		//コンボ状態をリセット
		SetComboStateNone();
		//ステート共通の状態遷移処理に遷移
		ProcessCommonStateTransition();
	}
}

bool Brave::RotationOnly()
{
	//回転可能なアニメーションなら
	if (isRotationEntable() == true &&
		m_useWeapon[enWeapon_Main].weapon->GetEnDefendTipe()==IWeapon::enDefendTipe_Defence)
	{
		return true;
	}

	return false;
}

void Brave::ReverseWeapon()
{
	//武器のサブとメインの中身を入れ替える
	ChangeUseWeapon();

	//メイン武器とサブ武器の状態ステートを逆にする
	m_useWeapon[enWeapon_Main].weapon->ReverseWeaponState();
	m_useWeapon[enWeapon_Sub].weapon->ReverseWeaponState();
}

void Brave::ChangeUseWeapon()
{
	UseWeapon temporary;
	temporary = m_useWeapon[enWeapon_Main];
	m_useWeapon[enWeapon_Main] = m_useWeapon[enWeapon_Sub];
	m_useWeapon[enWeapon_Sub] = temporary;

	//現在の武器のアニメーションクリップの最初の番号を変更
	m_currentAnimationStartIndexNo
		= m_useWeapon[enWeapon_Main].weaponAnimationStartIndexNo;
}

bool Brave::IsDefendHit()
{
	//ガード中なら
	if (m_enAnimationState == enAnimationState_Defend)
	{
		//盾に当たっているなら
		if (m_useWeapon[enWeapon_Main].weapon->IsHitCollision() == true)
		{
			return true;
		}
		return false;
	}
	else
	{
		return false;
	}
}

void Brave::InitModel()
{
	// 片手剣のアニメーションクリップをロードする
	const std::pair<const char*, bool> oneHandedSwordAnimClipFilePaths[] = {
		{"Assets/animData/character/Player/OneHandSword/Idle.tka",true},
		{"Assets/animData/character/Player/OneHandSword/Sprint.tka",true},
		{"Assets/animData/character/Player/OneHandSword/KnockBack.tka",false},
		{"Assets/animData/character/Player/OneHandSword/Hit.tka",false},
		{ "Assets/animData/character/Player/OneHandSword/Defend.tka", true },
		{ "Assets/animData/character/Player/OneHandSword/DefendHit.tka", false },
		{ "Assets/animData/character/Player/OneHandSword/Die.tka", false },
		{"Assets/animData/character/Player/OneHandSword/ChangeSwordShield.tka",false},
		{"Assets/animData/character/Player/OneHandSword/Win_start.tka",false},
		{"Assets/animData/character/Player/OneHandSword/Win_main.tka",false},
		{"Assets/animData/character/Player/OneHandSword/Attack_1.tka",false},
		{"Assets/animData/character/Player/OneHandSword/Attack_2.tka",false},
		{"Assets/animData/character/Player/OneHandSword/Attack_3.tka",false},
		{"Assets/animData/character/Player/OneHandSword/Attack_4.tka",false},
		{"Assets/animData/character/Player/OneHandSword/Attack_5.tka",false},
		{"None",false}
	};
	for (int i = 0; i < enAnimClip_Num; i++) {
		m_animationClip[i].Load(oneHandedSwordAnimClipFilePaths[i].first);
		m_animationClip[i].SetLoopFlag(oneHandedSwordAnimClipFilePaths[i].second);
	}

	// 両手剣のアニメーションクリップをロードする
	const std::pair<const char*, bool> twoHandedSwordAnimClipFilePaths[] = {
		{"Assets/animData/character/Player/TwoHandSword/idle_BigSword.tka",true},
		{"Assets/animData/character/Player/TwoHandSword/Sprint.tka",true},
		{"Assets/animData/character/Player/TwoHandSword/KnockBack.tka",false},
		{"Assets/animData/character/Player/TwoHandSword/Hit.tka",false},
		{ "Assets/animData/character/Player/TwoHandSword/Rool.tka", false },
		{ "Assets/animData/character/Player/TwoHandSword/Rool.tka", false },
		{ "Assets/animData/character/Player/TwoHandSword/Die.tka", false },
		{"Assets/animData/character/Player/TwoHandSword/ChangeTwoHandSword.tka",false},
		{"Assets/animData/character/Player/TwoHandSword/Win_Start.tka",false},
		{"Assets/animData/character/Player/TwoHandSword/Win_Main.tka",false},
		{"Assets/animData/character/Player/TwoHandSword/Attack_1.tka",false},
		{"Assets/animData/character/Player/TwoHandSword/Attack_2.tka",false},
		{"Assets/animData/character/Player/TwoHandSword/Attack_3.tka",false},
		{"Assets/animData/character/Player/TwoHandSword/Skill_Start.tka",false},
		{"Assets/animData/character/Player/TwoHandSword/Skill_Main.tka",false},
		{"None",false}
	};
	for (int i = 0; i < enAnimClip_Num; i++) {
		m_animationClip[TwoHandSwordAnimationStartIndexNo + i].Load(twoHandedSwordAnimClipFilePaths[i].first);
		m_animationClip[TwoHandSwordAnimationStartIndexNo + i].SetLoopFlag(twoHandedSwordAnimClipFilePaths[i].second);
	}

	m_modelRender.Init("Assets/modelData/character/Player/NewHero/Hero_Smile.tkm",
		L"Assets/shader/ToonTextrue/lamp_glay.DDS",
		m_animationClip,
		enAnimClip_Num * AnimationClipGroup_Num,
		enModelUpAxisZ
	);
	
	m_modelRender.SetPosition(m_position);
	m_modelRender.Update();

	m_charaCenterBoonId = m_modelRender.FindBoneID(L"root");

	//アニメーションイベント用の関数を設定する。
	m_modelRender.AddAnimationEvent([&](const wchar_t* clipName, const wchar_t* eventName) {
		OnAnimationEvent(clipName, eventName);
		});
}

void Brave::Render(RenderContext& rc)
{
	if (IsFlashing() != true)
	{
		m_modelRender.Draw(rc);
	}
}

void Brave::OnAnimationEvent(const wchar_t* clipName, const wchar_t* eventName)
{
	///////////////////////////////////////////////////////////
	// 全武器共通処理
	/////////////////////////////////////////////////////////// 
	//コンボ受付が可能なら
	if (wcscmp(eventName, L"ComboAcceptable") == 0)
	{
		SetIsComboReceptionFlagFlag(true);
	}
	//前進する始まり
	if (wcscmp(eventName, L"MoveForwardStart") == 0)
	{
		SetMoveforwardFlag(true);
	}
	//前進する終わり
	if (wcscmp(eventName, L"MoveForwardEnd") == 0)
	{
		SetMoveforwardFlag(false);
	}

	//武器入れ替え
	if (wcscmp(eventName, L"ArmedSwordShield") == 0)
	{
		ReverseWeapon();
	}

	//攻撃当たり判定の有効化
	if (wcscmp(eventName, L"CollisionStart") == 0)
	{
		SetIsCollisionPossibleFlag(true);
	}
	//攻撃当たり判定の無効化
	if (wcscmp(eventName, L"CollisionEnd") == 0)
	{
		SetIsCollisionPossibleFlag(false);
	}

	//無敵状態の有効化
	if (wcscmp(eventName, L"InvisibleStart") == 0)
	{
		SetInvicibleFlag(true);
	}
	//無敵状態の無効化
	if (wcscmp(eventName, L"InvisibleEnd") == 0)
	{
		SetInvicibleFlag(false);
	}

	////スキル使用時の攻撃処理
	if (wcscmp(eventName, L"SkillAttack") == 0)
	{
		int a = 0;
	}
	//スキルのジャンプ処理
	if (wcscmp(eventName, L"Jamp") == 0)
	{
		ProcessSwordShieldSkill(true);
	}
	//スキルのジャンプ処理
	if (wcscmp(eventName, L"Down") == 0)
	{
		ProcessSwordShieldSkill(false);
	}

	

	////////////////////////////////////////////////////////////
	// 剣盾の処理
	////////////////////////////////////////////////////////////

}

bool Brave::isCollisionEntable() const
{
	//もし武器の防御タイプが盾などで防ぐタイプなら
	if (m_useWeapon[enWeapon_Main].weapon->GetEnDefendTipe()==IWeapon::enDefendTipe_Defence)
	{
		return m_enAnimationState == enAnimationState_Hit ||
			m_enAnimationState == enAnimationState_DefendHit;
	}
	//それ以外(回避)なら
	else
	{
		return m_enAnimationState == enAnimationState_Hit ||
			m_enAnimationState == enAnimationState_Defend ||
			m_enAnimationState == enAnimationState_DefendHit;
	}
}
